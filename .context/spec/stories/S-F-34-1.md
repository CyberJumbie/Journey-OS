# S-F-34-1: Notification Model & Repository

**Epic:** E-34 (Notification System)
**Feature:** F-16
**Sprint:** 19
**Lane:** faculty (P3)
**Size:** M

## User Story
As a **Faculty member**, I need a notification data model with read/unread tracking so that the platform can persist and manage notifications reliably.

## Acceptance Criteria
- [ ] Supabase `notifications` table: id, user_id, type, title, body, metadata (JSONB), read, created_at
- [ ] Notification types enum: `batch_complete`, `review_request`, `review_decision`, `gap_scan`, `lint_alert`, `drift_detected`, `system`
- [ ] Repository: create, findByUserId (paginated), markAsRead, markAllAsRead, deleteOld
- [ ] Unread count query: efficient count of unread notifications per user
- [ ] Retention policy: auto-delete notifications older than configurable TTL (default 90 days)
- [ ] Index on (user_id, read, created_at) for efficient queries
- [ ] Model class with private fields, public getters, constructor DI
- [ ] Custom error class: `NotificationError`
- [ ] 10-14 API tests: CRUD operations, pagination, unread count, retention cleanup, type filtering
- [ ] TypeScript strict, named exports only

## Implementation Layers
| Layer | Package | Files |
|-------|---------|-------|
| Types | packages/types | `src/notification/notification.types.ts` |
| Model | apps/server | `src/models/notification.model.ts` |
| Repository | apps/server | `src/repositories/notification.repository.ts` |
| Migration | apps/server | `src/migrations/create-notifications-table.sql` |
| Errors | apps/server | `src/errors/notification.errors.ts` |
| Tests | apps/server | `src/tests/notification/notification.repository.test.ts` |

## Dependencies
- **Blocks:** S-F-34-2, S-F-34-3, S-F-34-4
- **Blocked by:** S-U-01-3 (auth — user_id FK requires auth system)
- **Cross-epic:** S-U-01-3 (Sprint 1 auth)

## Notes
- Metadata JSONB stores type-specific payload: e.g., batch_complete has { batchId, successCount, failCount }
- Unread count uses `SELECT COUNT(*) WHERE user_id = $1 AND read = false` — consider caching for high-traffic
- Retention cleanup: Inngest cron job running weekly to delete expired notifications
- Table RLS: users can only read/modify their own notifications
- Consider Supabase Realtime subscription as alternative to polling for unread count updates
- Notification model follows OOP pattern: private fields, public getters
